// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract Lottery {
    address immutable manager; // Address of the manager who deploys the contract
    address[] players; // Array to store the addresses of participants

    // Constructor initializes the manager as the address that deploys the contract
    constructor() {
        manager = msg.sender;
    }

    // Modifier to restrict access to certain functions to only the manager
    modifier restricted() {
        /* The require statement checks if the sender of the current transaction (msg.sender) is equal to the manager's address (manager). 
        If they are not the same, the function will revert with the error message*/

        if (msg.sender != manager) revert();
        _;

        /* The underscore (_) is a placeholder that represents the body of the function that the modifier is applied to. 
        When the modifier is used, the code in the modified function is executed at the location of the underscore. */
    }

    // Function for participants to enter the lottery by sending a minimum of 0.01 ether
    function enter() public payable {
        if (msg.value < .01 ether) revert();

        // This require statement ensures that participants calling the enter function must send at least 0.01 Ether along with their transaction.

        players.push(msg.sender);

        /* The line players.push(msg.sender) adds the Ethereum address of the participant (msg.sender) to the end of the players array;
        it records the address of a participant who has successfully entered the lottery by sending the required amount of Ether */
    }

    /* This function generates a pseudo-random number based on the current block's difficulty, timestamp, and the addresses of the participants (players). 
     Note that using block.timestamp for randomness might have security implications, and for more secure randomness, you might want to explore additional 
     solutions such as Chainlink VRF (Verifiable Random Function) oracles.*/

    function random() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(block.timestamp, players)));

        /* This line of code combines the block difficulty, block timestamp, and the array of player addresses, and then applies a cryptographic hash function to generate a pseudo-random number. 
        This number is converted to an unsigned integer and returned by the random function. The goal is to introduce an element of randomness based on these blockchain-specific values for selecting a winner in a lottery-like scenario. 
        However, it's important to note that using block.timestamp for randomness may have security considerations, and for more secure randomness, additional methods such as Chainlink VRF (Verifiable Random Function) oracles 
        are recommended in certain contexts. 
        
        - block.timestamp: This is the current timestamp of the block. It represents the time when the block was mined. Miners try to set this timestamp to a value close to the actual time,
            but it is not entirely accurate due to the decentralized nature of the network.
        - players: This is an array containing the addresses of the participants in the lottery. 
        - abi.encodePacked(...): This function is used to tightly pack the provided arguments into a byte array. It concatenates the values without adding any additional padding, resulting in a more efficient use of space.
        - keccak256(...): This is a cryptographic hash function (Keccak-256) that takes the tightly packed byte array from abi.encodePacked as input and produces a 256-bit (32-byte) hash.*/
    }

    // Function for the manager to pick a winner randomly and transfer the contract balance to the winner
    function pickWinner() public restricted {
        uint index = random() % players.length; // Calculate the index of the winning player

        /* This line of code is calculating a random index within the range of the number of players. 
        It does so by taking the remainder of the division of a pseudo-random number (generated by the random function) by the length of the players array. 
        The resulting index is then used to select a random participant from the players array for the lottery or prize-picking logic in the contract. 
        The % operator calculates the remainder of the division of the pseudo-random number by the number of players (players.length). 
        This operation ensures that the resulting index is within the bounds of the players array.*/

        address winner = players[index]; // Get the address of the winner
        address payable winnerPayable = payable(winner); // Convert the winner's address to a payable address

        winnerPayable.transfer(address(this).balance); // Transfer the contract balance to the winner

        /* This line is transferring the entire balance of the contract (address(this).balance) to the address of the participant who won the lottery (winnerPayable). 
        This line is typically found in a function that declares the winner and distributes the funds to them. 
        The use of transfer ensures that the Ether is sent to the winner's address, and it also protects against reentrancy attacks by only allowing a certain amount of gas to be used in the transfer operation. 
        address(this): This represents the contract's address. In Solidity, address(this) refers to the address of the current contract.*/

        players = new address[](0); // Reset the players array to empty for the next round

        /* This line of code is resetting the players array to a new empty array. It's a common pattern used in contracts to clear or reset dynamic arrays. In the context of a lottery contract, 
        after a winner has been determined and the funds have been transferred, the players array is reset to prepare for the next round of the lottery. 
        This ensures that the array is empty, and new participants can enter the lottery for the next draw. 
        new address[](0): This part creates a new dynamic array of type address with a length of 0 (empty).*/
    }

    // Function to retrieve the addresses of participants
    function getPlayers() public view returns (address[] memory) {
        return players;
    }
}
